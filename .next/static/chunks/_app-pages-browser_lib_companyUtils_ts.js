"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_lib_companyUtils_ts"],{

/***/ "(app-pages-browser)/./lib/companyUtils.ts":
/*!*****************************!*\
  !*** ./lib/companyUtils.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CompanyService: function() { return /* binding */ CompanyService; },\n/* harmony export */   calculateSimilarity: function() { return /* binding */ calculateSimilarity; },\n/* harmony export */   companyService: function() { return /* binding */ companyService; },\n/* harmony export */   generateAliases: function() { return /* binding */ generateAliases; },\n/* harmony export */   getCompanyInsights: function() { return /* binding */ getCompanyInsights; },\n/* harmony export */   normalizeCompanyName: function() { return /* binding */ normalizeCompanyName; },\n/* harmony export */   updateCompanyInsights: function() { return /* binding */ updateCompanyInsights; }\n/* harmony export */ });\n/* harmony import */ var firebase_firestore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! firebase/firestore */ \"(app-pages-browser)/./node_modules/firebase/firestore/dist/esm/index.esm.js\");\n/* harmony import */ var _firebase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./firebase */ \"(app-pages-browser)/./lib/firebase.ts\");\n\n\n// Global cache with TTL\nconst CACHE_TTL = 5 * 60 * 1000; // 5 minutes\nlet companyCache = {\n    companies: [],\n    lastUpdated: 0,\n    isLoaded: false\n};\n/**\n * Normalize company name for consistent searching\n */ const normalizeCompanyName = (input)=>{\n    if (!input) return \"\";\n    return input.trim().toLowerCase().replace(/\\s+/g, \" \") // Normalize whitespace\n    .replace(/[^\\w\\s-]/g, \"\") // Remove special characters except hyphens\n    .replace(/\\b(inc|corp|corporation|llc|ltd|limited|co|company|group|holdings|enterprises|ventures|partners|associates)\\b/g, \"\") // Remove common suffixes\n    .replace(/\\b(the|a|an)\\b/g, \"\") // Remove common prefixes\n    .replace(/\\s+/g, \" \") // Normalize whitespace again\n    .trim();\n};\n/**\n * Generate aliases for a company name\n */ const generateAliases = (name, website)=>{\n    const aliases = [];\n    if (!name) return aliases;\n    // Add original name\n    aliases.push(name.trim());\n    // Add lowercase version\n    aliases.push(name.toLowerCase().trim());\n    // Add without common suffixes\n    const nameClean = name.toLowerCase().replace(/\\b(inc|corp|corporation|llc|ltd|limited|co|company|group|holdings|enterprises|ventures|partners|associates)\\b/g, \"\").replace(/\\s+/g, \" \").trim();\n    if (nameClean && nameClean !== name.toLowerCase().trim()) {\n        aliases.push(nameClean);\n    }\n    // Add domain-based alias if website exists\n    if (website) {\n        try {\n            const url = new URL(website);\n            const domain = url.hostname;\n            if (domain && domain !== name.toLowerCase()) {\n                aliases.push(domain);\n                // Add without www\n                if (domain.startsWith(\"www.\")) {\n                    aliases.push(domain.substring(4));\n                }\n            }\n        } catch (e) {\n        // Invalid URL, skip\n        }\n    }\n    // Remove duplicates and empty strings\n    return Array.from(new Set(aliases.filter((alias)=>alias.trim())));\n};\n/**\n * Calculate similarity between two strings using Levenshtein distance\n */ const calculateSimilarity = (str1, str2)=>{\n    if (!str1 || !str2) return 0;\n    const matrix = [];\n    const len1 = str1.length;\n    const len2 = str2.length;\n    // Initialize matrix\n    for(let i = 0; i <= len2; i++){\n        matrix[i] = [\n            i\n        ];\n    }\n    for(let j = 0; j <= len1; j++){\n        matrix[0][j] = j;\n    }\n    // Fill matrix\n    for(let i = 1; i <= len2; i++){\n        for(let j = 1; j <= len1; j++){\n            if (str2.charAt(i - 1) === str1.charAt(j - 1)) {\n                matrix[i][j] = matrix[i - 1][j - 1];\n            } else {\n                matrix[i][j] = Math.min(matrix[i - 1][j - 1] + 1, matrix[i][j - 1] + 1, matrix[i - 1][j] + 1 // deletion\n                );\n            }\n        }\n    }\n    // Calculate similarity percentage\n    const maxLength = Math.max(len1, len2);\n    return maxLength === 0 ? 1 : (maxLength - matrix[len2][len1]) / maxLength;\n};\n/**\n * Optimized company search and management with caching\n */ class CompanyService {\n    static getInstance() {\n        if (!CompanyService.instance) {\n            CompanyService.instance = new CompanyService();\n        }\n        return CompanyService.instance;\n    }\n    /**\n   * Load all companies from database with caching\n   */ async loadAllCompanies() {\n        const now = Date.now();\n        // Return cached data if still valid\n        if (companyCache.isLoaded && now - companyCache.lastUpdated < CACHE_TTL) {\n            return companyCache.companies;\n        }\n        try {\n            if (!this.db) {\n                console.warn(\"Firebase not initialized\");\n                return [];\n            }\n            const companiesRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(this.db, \"companies\");\n            const snapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(companiesRef);\n            const companies = snapshot.docs.map((doc)=>{\n                var _data_lastSubmission, _data_createdAt, _data_updatedAt;\n                const data = doc.data();\n                return {\n                    id: doc.id,\n                    name: data.name || \"\",\n                    normalizedName: data.normalizedName || \"\",\n                    aliases: data.aliases || [],\n                    website: data.website,\n                    location: data.location,\n                    industry: data.industry,\n                    company_size: data.company_size,\n                    company_type: data.company_type,\n                    founded_year: data.founded_year,\n                    specialities: data.specialities,\n                    locations: data.locations,\n                    submissionCount: data.submissionCount || 0,\n                    lastSubmission: (_data_lastSubmission = data.lastSubmission) === null || _data_lastSubmission === void 0 ? void 0 : _data_lastSubmission.toDate(),\n                    commonFlags: data.commonFlags || [],\n                    averageFlagCount: data.averageFlagCount || 0,\n                    severityTrends: data.severityTrends || {\n                        light: 0,\n                        medium: 0\n                    },\n                    createdAt: (_data_createdAt = data.createdAt) === null || _data_createdAt === void 0 ? void 0 : _data_createdAt.toDate(),\n                    updatedAt: (_data_updatedAt = data.updatedAt) === null || _data_updatedAt === void 0 ? void 0 : _data_updatedAt.toDate()\n                };\n            });\n            // Update cache\n            companyCache = {\n                companies,\n                lastUpdated: now,\n                isLoaded: true\n            };\n            console.log(\"Loaded \".concat(companies.length, \" companies\"));\n            return companies;\n        } catch (error) {\n            console.error(\"Error loading companies:\", error);\n            return [];\n        }\n    }\n    /**\n   * Search companies with optimized caching\n   */ async searchCompanies(query) {\n        let limit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 10;\n        if (!query.trim()) return [];\n        const companies = await this.loadAllCompanies();\n        const normalizedQuery = normalizeCompanyName(query);\n        const results = [];\n        for (const company of companies){\n            let bestScore = 0;\n            let matchType = \"fuzzy\";\n            // Check exact matches first\n            if (company.normalizedName === normalizedQuery) {\n                bestScore = 1.0;\n                matchType = \"exact\";\n            } else if (company.name.toLowerCase().includes(query.toLowerCase())) {\n                bestScore = 0.9;\n                matchType = \"partial\";\n            } else {\n                // Check aliases\n                for (const alias of company.aliases){\n                    const aliasNormalized = normalizeCompanyName(alias);\n                    if (aliasNormalized === normalizedQuery) {\n                        bestScore = 0.8;\n                        matchType = \"alias\";\n                        break;\n                    }\n                }\n                // If no exact matches, try fuzzy matching\n                if (bestScore === 0) {\n                    const similarity = calculateSimilarity(normalizedQuery, company.normalizedName);\n                    if (similarity > 0.7) {\n                        bestScore = similarity;\n                        matchType = \"fuzzy\";\n                    }\n                }\n            }\n            if (bestScore > 0) {\n                results.push({\n                    company,\n                    relevanceScore: bestScore,\n                    matchType\n                });\n            }\n        }\n        // Sort by relevance and return top results\n        return results.sort((a, b)=>b.relevanceScore - a.relevanceScore).slice(0, limit).map((result)=>result.company);\n    }\n    /**\n   * Find or create company with caching\n   */ async findOrCreateCompany(companyName) {\n        if (!companyName.trim()) {\n            throw new Error(\"Company name cannot be empty\");\n        }\n        // First try to find existing company\n        const searchResults = await this.searchCompanies(companyName, 1);\n        if (searchResults.length > 0) {\n            const bestMatch = searchResults[0];\n            const similarity = calculateSimilarity(normalizeCompanyName(companyName), bestMatch.normalizedName);\n            // If similarity is high enough, return existing company\n            if (similarity > 0.8) {\n                return bestMatch;\n            }\n        }\n        // Create new company if no good match found\n        return this.createCompany(companyName);\n    }\n    /**\n   * Create new company\n   */ async createCompany(companyName) {\n        if (!this.db) {\n            throw new Error(\"Firebase not initialized\");\n        }\n        const normalizedName = normalizeCompanyName(companyName);\n        const aliases = generateAliases(companyName);\n        const companyData = {\n            name: companyName.trim(),\n            normalizedName,\n            aliases,\n            submissionCount: 0,\n            commonFlags: [],\n            averageFlagCount: 0,\n            severityTrends: {\n                light: 0,\n                medium: 0\n            },\n            createdAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.serverTimestamp)(),\n            updatedAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.serverTimestamp)()\n        };\n        try {\n            const docRef = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.addDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(this.db, \"companies\"), companyData);\n            const newCompany = {\n                id: docRef.id,\n                ...companyData,\n                createdAt: new Date(),\n                updatedAt: new Date()\n            };\n            // Add to cache\n            companyCache.companies.push(newCompany);\n            return newCompany;\n        } catch (error) {\n            console.error(\"Error creating company:\", error);\n            throw error;\n        }\n    }\n    /**\n   * Update company with submission data\n   */ async updateCompanyWithSubmission(companyId, submissionData) {\n        if (!this.db) {\n            console.warn(\"Firebase not initialized. Skipping company update.\");\n            return;\n        }\n        try {\n            const docRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(this.db, \"companies\", companyId);\n            // Get current company data\n            const company = companyCache.companies.find((c)=>c.id === companyId);\n            if (!company) {\n                console.warn(\"Company not found in cache for update\");\n                return;\n            }\n            const updatedData = {\n                submissionCount: company.submissionCount + 1,\n                commonFlags: Array.from(new Set([\n                    ...company.commonFlags,\n                    ...submissionData.markedFlags\n                ])),\n                averageFlagCount: (company.averageFlagCount * company.submissionCount + submissionData.markedFlags.length) / (company.submissionCount + 1),\n                severityTrends: {\n                    light: company.severityTrends.light + submissionData.severityBreakdown.light,\n                    medium: company.severityTrends.medium + submissionData.severityBreakdown.medium\n                },\n                lastSubmission: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.serverTimestamp)(),\n                updatedAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.serverTimestamp)()\n            };\n            await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.updateDoc)(docRef, updatedData);\n            // Update cache\n            const cacheIndex = companyCache.companies.findIndex((c)=>c.id === companyId);\n            if (cacheIndex !== -1) {\n                companyCache.companies[cacheIndex] = {\n                    ...company,\n                    ...updatedData,\n                    lastSubmission: new Date(),\n                    updatedAt: new Date()\n                };\n            }\n        } catch (error) {\n            console.error(\"Error updating company with submission:\", error);\n        // Don't throw error - company update is not critical\n        }\n    }\n    /**\n   * Refresh companies cache\n   */ async refreshCompanies() {\n        companyCache = {\n            companies: [],\n            lastUpdated: 0,\n            isLoaded: false\n        };\n        await this.loadAllCompanies();\n    }\n    /**\n   * Get all companies (cached)\n   */ async getAllCompanies() {\n        return this.loadAllCompanies();\n    }\n    constructor(){\n        this.db = (0,_firebase__WEBPACK_IMPORTED_MODULE_1__.getFirestoreDB)();\n    // Private constructor for singleton\n    }\n}\n// Export singleton instance\nconst companyService = CompanyService.getInstance();\n// Legacy functions for backward compatibility\nconst getCompanyInsights = async (companyName)=>{\n    const companies = await companyService.searchCompanies(companyName, 1);\n    return companies.length > 0 ? companies[0] : null;\n};\nconst updateCompanyInsights = async (companyName, submissionData)=>{\n    const companies = await companyService.searchCompanies(companyName, 1);\n    if (companies.length > 0) {\n        await companyService.updateCompanyWithSubmission(companies[0].id, submissionData);\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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OUI7SUE1UUEsYUFBc0I7YUFGZEcsS0FBS2hELHlEQUFjQTtJQUd6QixvQ0FBb0M7SUFDdEM7QUEyUUY7QUFFQSw0QkFBNEI7QUFDckIsTUFBTW1ILGlCQUFpQnpFLGVBQWVDLFdBQVcsR0FBRztBQUUzRCw4Q0FBOEM7QUFDdkMsTUFBTXlFLHFCQUFxQixPQUFPckI7SUFDdkMsTUFBTTVGLFlBQVksTUFBTWdILGVBQWV0QyxlQUFlLENBQUNrQixhQUFhO0lBQ3BFLE9BQU81RixVQUFVOEIsTUFBTSxHQUFHLElBQUk5QixTQUFTLENBQUMsRUFBRSxHQUFHO0FBQy9DLEVBQUU7QUFFSyxNQUFNa0gsd0JBQXdCLE9BQU90QixhQUFxQlU7SUFDL0QsTUFBTXRHLFlBQVksTUFBTWdILGVBQWV0QyxlQUFlLENBQUNrQixhQUFhO0lBQ3BFLElBQUk1RixVQUFVOEIsTUFBTSxHQUFHLEdBQUc7UUFDeEIsTUFBTWtGLGVBQWVaLDJCQUEyQixDQUFDcEcsU0FBUyxDQUFDLEVBQUUsQ0FBQ3FELEVBQUUsRUFBRWlEO0lBQ3BFO0FBQ0YsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvY29tcGFueVV0aWxzLnRzPzJiNTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgXG4gIGNvbGxlY3Rpb24sIFxuICBnZXREb2NzLCBcbiAgYWRkRG9jLCBcbiAgdXBkYXRlRG9jLCBcbiAgZG9jLCBcbiAgcXVlcnksIFxuICB3aGVyZSwgXG4gIGxpbWl0LCBcbiAgb3JkZXJCeSxcbiAgc2VydmVyVGltZXN0YW1wLFxuICBUaW1lc3RhbXBcbn0gZnJvbSAnZmlyZWJhc2UvZmlyZXN0b3JlJztcbmltcG9ydCB7IGdldEZpcmVzdG9yZURCIH0gZnJvbSAnLi9maXJlYmFzZSc7XG5cbi8vIFVuaWZpZWQgQ29tcGFueSBJbnRlcmZhY2VcbmV4cG9ydCBpbnRlcmZhY2UgQ29tcGFueSB7XG4gIGlkOiBzdHJpbmc7XG4gIG5hbWU6IHN0cmluZztcbiAgbm9ybWFsaXplZE5hbWU6IHN0cmluZztcbiAgYWxpYXNlczogc3RyaW5nW107XG4gIHdlYnNpdGU/OiBzdHJpbmc7XG4gIGxvY2F0aW9uPzogc3RyaW5nO1xuICBpbmR1c3RyeT86IHN0cmluZztcbiAgY29tcGFueV9zaXplPzogc3RyaW5nO1xuICBjb21wYW55X3R5cGU/OiBzdHJpbmc7XG4gIGZvdW5kZWRfeWVhcj86IG51bWJlcjtcbiAgc3BlY2lhbGl0aWVzPzogc3RyaW5nO1xuICBsb2NhdGlvbnM/OiBzdHJpbmc7XG4gIFxuICAvLyBEeW5hbWljIGZpZWxkcyBmcm9tIHN1Ym1pc3Npb25zXG4gIHN1Ym1pc3Npb25Db3VudDogbnVtYmVyO1xuICBsYXN0U3VibWlzc2lvbj86IERhdGU7XG4gIGNvbW1vbkZsYWdzOiBzdHJpbmdbXTtcbiAgYXZlcmFnZUZsYWdDb3VudDogbnVtYmVyO1xuICBzZXZlcml0eVRyZW5kczoge1xuICAgIGxpZ2h0OiBudW1iZXI7XG4gICAgbWVkaXVtOiBudW1iZXI7XG4gIH07XG4gIFxuICAvLyBNZXRhZGF0YVxuICBjcmVhdGVkQXQ/OiBEYXRlO1xuICB1cGRhdGVkQXQ/OiBEYXRlO1xufVxuXG4vLyBTZWFyY2ggUmVzdWx0IHdpdGggcmVsZXZhbmNlIHNjb3JlXG5leHBvcnQgaW50ZXJmYWNlIFNlYXJjaFJlc3VsdCB7XG4gIGNvbXBhbnk6IENvbXBhbnk7XG4gIHJlbGV2YW5jZVNjb3JlOiBudW1iZXI7XG4gIG1hdGNoVHlwZTogJ2V4YWN0JyB8ICdwYXJ0aWFsJyB8ICdmdXp6eScgfCAnYWxpYXMnO1xufVxuXG4vLyBDYWNoZSBpbnRlcmZhY2VcbmludGVyZmFjZSBDb21wYW55Q2FjaGUge1xuICBjb21wYW5pZXM6IENvbXBhbnlbXTtcbiAgbGFzdFVwZGF0ZWQ6IG51bWJlcjtcbiAgaXNMb2FkZWQ6IGJvb2xlYW47XG59XG5cbi8vIEdsb2JhbCBjYWNoZSB3aXRoIFRUTFxuY29uc3QgQ0FDSEVfVFRMID0gNSAqIDYwICogMTAwMDsgLy8gNSBtaW51dGVzXG5sZXQgY29tcGFueUNhY2hlOiBDb21wYW55Q2FjaGUgPSB7XG4gIGNvbXBhbmllczogW10sXG4gIGxhc3RVcGRhdGVkOiAwLFxuICBpc0xvYWRlZDogZmFsc2Vcbn07XG5cbi8qKlxuICogTm9ybWFsaXplIGNvbXBhbnkgbmFtZSBmb3IgY29uc2lzdGVudCBzZWFyY2hpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IG5vcm1hbGl6ZUNvbXBhbnlOYW1lID0gKGlucHV0OiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xuICBpZiAoIWlucHV0KSByZXR1cm4gJyc7XG4gIFxuICByZXR1cm4gaW5wdXRcbiAgICAudHJpbSgpXG4gICAgLnRvTG93ZXJDYXNlKClcbiAgICAucmVwbGFjZSgvXFxzKy9nLCAnICcpIC8vIE5vcm1hbGl6ZSB3aGl0ZXNwYWNlXG4gICAgLnJlcGxhY2UoL1teXFx3XFxzLV0vZywgJycpIC8vIFJlbW92ZSBzcGVjaWFsIGNoYXJhY3RlcnMgZXhjZXB0IGh5cGhlbnNcbiAgICAucmVwbGFjZSgvXFxiKGluY3xjb3JwfGNvcnBvcmF0aW9ufGxsY3xsdGR8bGltaXRlZHxjb3xjb21wYW55fGdyb3VwfGhvbGRpbmdzfGVudGVycHJpc2VzfHZlbnR1cmVzfHBhcnRuZXJzfGFzc29jaWF0ZXMpXFxiL2csICcnKSAvLyBSZW1vdmUgY29tbW9uIHN1ZmZpeGVzXG4gICAgLnJlcGxhY2UoL1xcYih0aGV8YXxhbilcXGIvZywgJycpIC8vIFJlbW92ZSBjb21tb24gcHJlZml4ZXNcbiAgICAucmVwbGFjZSgvXFxzKy9nLCAnICcpIC8vIE5vcm1hbGl6ZSB3aGl0ZXNwYWNlIGFnYWluXG4gICAgLnRyaW0oKTtcbn07XG5cbi8qKlxuICogR2VuZXJhdGUgYWxpYXNlcyBmb3IgYSBjb21wYW55IG5hbWVcbiAqL1xuZXhwb3J0IGNvbnN0IGdlbmVyYXRlQWxpYXNlcyA9IChuYW1lOiBzdHJpbmcsIHdlYnNpdGU/OiBzdHJpbmcpOiBzdHJpbmdbXSA9PiB7XG4gIGNvbnN0IGFsaWFzZXM6IHN0cmluZ1tdID0gW107XG4gIFxuICBpZiAoIW5hbWUpIHJldHVybiBhbGlhc2VzO1xuICBcbiAgLy8gQWRkIG9yaWdpbmFsIG5hbWVcbiAgYWxpYXNlcy5wdXNoKG5hbWUudHJpbSgpKTtcbiAgXG4gIC8vIEFkZCBsb3dlcmNhc2UgdmVyc2lvblxuICBhbGlhc2VzLnB1c2gobmFtZS50b0xvd2VyQ2FzZSgpLnRyaW0oKSk7XG4gIFxuICAvLyBBZGQgd2l0aG91dCBjb21tb24gc3VmZml4ZXNcbiAgY29uc3QgbmFtZUNsZWFuID0gbmFtZS50b0xvd2VyQ2FzZSgpXG4gICAgLnJlcGxhY2UoL1xcYihpbmN8Y29ycHxjb3Jwb3JhdGlvbnxsbGN8bHRkfGxpbWl0ZWR8Y298Y29tcGFueXxncm91cHxob2xkaW5nc3xlbnRlcnByaXNlc3x2ZW50dXJlc3xwYXJ0bmVyc3xhc3NvY2lhdGVzKVxcYi9nLCAnJylcbiAgICAucmVwbGFjZSgvXFxzKy9nLCAnICcpXG4gICAgLnRyaW0oKTtcbiAgXG4gIGlmIChuYW1lQ2xlYW4gJiYgbmFtZUNsZWFuICE9PSBuYW1lLnRvTG93ZXJDYXNlKCkudHJpbSgpKSB7XG4gICAgYWxpYXNlcy5wdXNoKG5hbWVDbGVhbik7XG4gIH1cbiAgXG4gIC8vIEFkZCBkb21haW4tYmFzZWQgYWxpYXMgaWYgd2Vic2l0ZSBleGlzdHNcbiAgaWYgKHdlYnNpdGUpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgdXJsID0gbmV3IFVSTCh3ZWJzaXRlKTtcbiAgICAgIGNvbnN0IGRvbWFpbiA9IHVybC5ob3N0bmFtZTtcbiAgICAgIGlmIChkb21haW4gJiYgZG9tYWluICE9PSBuYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgYWxpYXNlcy5wdXNoKGRvbWFpbik7XG4gICAgICAgIC8vIEFkZCB3aXRob3V0IHd3d1xuICAgICAgICBpZiAoZG9tYWluLnN0YXJ0c1dpdGgoJ3d3dy4nKSkge1xuICAgICAgICAgIGFsaWFzZXMucHVzaChkb21haW4uc3Vic3RyaW5nKDQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2gge1xuICAgICAgLy8gSW52YWxpZCBVUkwsIHNraXBcbiAgICB9XG4gIH1cbiAgXG4gIC8vIFJlbW92ZSBkdXBsaWNhdGVzIGFuZCBlbXB0eSBzdHJpbmdzXG4gIHJldHVybiBBcnJheS5mcm9tKG5ldyBTZXQoYWxpYXNlcy5maWx0ZXIoYWxpYXMgPT4gYWxpYXMudHJpbSgpKSkpO1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGUgc2ltaWxhcml0eSBiZXR3ZWVuIHR3byBzdHJpbmdzIHVzaW5nIExldmVuc2h0ZWluIGRpc3RhbmNlXG4gKi9cbmV4cG9ydCBjb25zdCBjYWxjdWxhdGVTaW1pbGFyaXR5ID0gKHN0cjE6IHN0cmluZywgc3RyMjogc3RyaW5nKTogbnVtYmVyID0+IHtcbiAgaWYgKCFzdHIxIHx8ICFzdHIyKSByZXR1cm4gMDtcbiAgXG4gIGNvbnN0IG1hdHJpeCA9IFtdO1xuICBjb25zdCBsZW4xID0gc3RyMS5sZW5ndGg7XG4gIGNvbnN0IGxlbjIgPSBzdHIyLmxlbmd0aDtcblxuICAvLyBJbml0aWFsaXplIG1hdHJpeFxuICBmb3IgKGxldCBpID0gMDsgaSA8PSBsZW4yOyBpKyspIHtcbiAgICBtYXRyaXhbaV0gPSBbaV07XG4gIH1cbiAgZm9yIChsZXQgaiA9IDA7IGogPD0gbGVuMTsgaisrKSB7XG4gICAgbWF0cml4WzBdW2pdID0gajtcbiAgfVxuXG4gIC8vIEZpbGwgbWF0cml4XG4gIGZvciAobGV0IGkgPSAxOyBpIDw9IGxlbjI7IGkrKykge1xuICAgIGZvciAobGV0IGogPSAxOyBqIDw9IGxlbjE7IGorKykge1xuICAgICAgaWYgKHN0cjIuY2hhckF0KGkgLSAxKSA9PT0gc3RyMS5jaGFyQXQoaiAtIDEpKSB7XG4gICAgICAgIG1hdHJpeFtpXVtqXSA9IG1hdHJpeFtpIC0gMV1baiAtIDFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF0cml4W2ldW2pdID0gTWF0aC5taW4oXG4gICAgICAgICAgbWF0cml4W2kgLSAxXVtqIC0gMV0gKyAxLCAvLyBzdWJzdGl0dXRpb25cbiAgICAgICAgICBtYXRyaXhbaV1baiAtIDFdICsgMSwgICAgIC8vIGluc2VydGlvblxuICAgICAgICAgIG1hdHJpeFtpIC0gMV1bal0gKyAxICAgICAgLy8gZGVsZXRpb25cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBDYWxjdWxhdGUgc2ltaWxhcml0eSBwZXJjZW50YWdlXG4gIGNvbnN0IG1heExlbmd0aCA9IE1hdGgubWF4KGxlbjEsIGxlbjIpO1xuICByZXR1cm4gbWF4TGVuZ3RoID09PSAwID8gMSA6IChtYXhMZW5ndGggLSBtYXRyaXhbbGVuMl1bbGVuMV0pIC8gbWF4TGVuZ3RoO1xufTtcblxuLyoqXG4gKiBPcHRpbWl6ZWQgY29tcGFueSBzZWFyY2ggYW5kIG1hbmFnZW1lbnQgd2l0aCBjYWNoaW5nXG4gKi9cbmV4cG9ydCBjbGFzcyBDb21wYW55U2VydmljZSB7XG4gIHByaXZhdGUgc3RhdGljIGluc3RhbmNlOiBDb21wYW55U2VydmljZTtcbiAgcHJpdmF0ZSBkYiA9IGdldEZpcmVzdG9yZURCKCk7XG5cbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcigpIHtcbiAgICAvLyBQcml2YXRlIGNvbnN0cnVjdG9yIGZvciBzaW5nbGV0b25cbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgZ2V0SW5zdGFuY2UoKTogQ29tcGFueVNlcnZpY2Uge1xuICAgIGlmICghQ29tcGFueVNlcnZpY2UuaW5zdGFuY2UpIHtcbiAgICAgIENvbXBhbnlTZXJ2aWNlLmluc3RhbmNlID0gbmV3IENvbXBhbnlTZXJ2aWNlKCk7XG4gICAgfVxuICAgIHJldHVybiBDb21wYW55U2VydmljZS5pbnN0YW5jZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkIGFsbCBjb21wYW5pZXMgZnJvbSBkYXRhYmFzZSB3aXRoIGNhY2hpbmdcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgbG9hZEFsbENvbXBhbmllcygpOiBQcm9taXNlPENvbXBhbnlbXT4ge1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgXG4gICAgLy8gUmV0dXJuIGNhY2hlZCBkYXRhIGlmIHN0aWxsIHZhbGlkXG4gICAgaWYgKGNvbXBhbnlDYWNoZS5pc0xvYWRlZCAmJiAobm93IC0gY29tcGFueUNhY2hlLmxhc3RVcGRhdGVkKSA8IENBQ0hFX1RUTCkge1xuICAgICAgcmV0dXJuIGNvbXBhbnlDYWNoZS5jb21wYW5pZXM7XG4gICAgfVxuICAgIFxuICAgIHRyeSB7XG4gICAgICBpZiAoIXRoaXMuZGIpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdGaXJlYmFzZSBub3QgaW5pdGlhbGl6ZWQnKTtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjb21wYW5pZXNSZWYgPSBjb2xsZWN0aW9uKHRoaXMuZGIsICdjb21wYW5pZXMnKTtcbiAgICAgIGNvbnN0IHNuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyhjb21wYW5pZXNSZWYpO1xuICAgICAgXG4gICAgICBjb25zdCBjb21wYW5pZXMgPSBzbmFwc2hvdC5kb2NzLm1hcChkb2MgPT4ge1xuICAgICAgICBjb25zdCBkYXRhID0gZG9jLmRhdGEoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpZDogZG9jLmlkLFxuICAgICAgICAgIG5hbWU6IGRhdGEubmFtZSB8fCAnJyxcbiAgICAgICAgICBub3JtYWxpemVkTmFtZTogZGF0YS5ub3JtYWxpemVkTmFtZSB8fCAnJyxcbiAgICAgICAgICBhbGlhc2VzOiBkYXRhLmFsaWFzZXMgfHwgW10sXG4gICAgICAgICAgd2Vic2l0ZTogZGF0YS53ZWJzaXRlLFxuICAgICAgICAgIGxvY2F0aW9uOiBkYXRhLmxvY2F0aW9uLFxuICAgICAgICAgIGluZHVzdHJ5OiBkYXRhLmluZHVzdHJ5LFxuICAgICAgICAgIGNvbXBhbnlfc2l6ZTogZGF0YS5jb21wYW55X3NpemUsXG4gICAgICAgICAgY29tcGFueV90eXBlOiBkYXRhLmNvbXBhbnlfdHlwZSxcbiAgICAgICAgICBmb3VuZGVkX3llYXI6IGRhdGEuZm91bmRlZF95ZWFyLFxuICAgICAgICAgIHNwZWNpYWxpdGllczogZGF0YS5zcGVjaWFsaXRpZXMsXG4gICAgICAgICAgbG9jYXRpb25zOiBkYXRhLmxvY2F0aW9ucyxcbiAgICAgICAgICBzdWJtaXNzaW9uQ291bnQ6IGRhdGEuc3VibWlzc2lvbkNvdW50IHx8IDAsXG4gICAgICAgICAgbGFzdFN1Ym1pc3Npb246IGRhdGEubGFzdFN1Ym1pc3Npb24/LnRvRGF0ZSgpLFxuICAgICAgICAgIGNvbW1vbkZsYWdzOiBkYXRhLmNvbW1vbkZsYWdzIHx8IFtdLFxuICAgICAgICAgIGF2ZXJhZ2VGbGFnQ291bnQ6IGRhdGEuYXZlcmFnZUZsYWdDb3VudCB8fCAwLFxuICAgICAgICAgIHNldmVyaXR5VHJlbmRzOiBkYXRhLnNldmVyaXR5VHJlbmRzIHx8IHsgbGlnaHQ6IDAsIG1lZGl1bTogMCB9LFxuICAgICAgICAgIGNyZWF0ZWRBdDogZGF0YS5jcmVhdGVkQXQ/LnRvRGF0ZSgpLFxuICAgICAgICAgIHVwZGF0ZWRBdDogZGF0YS51cGRhdGVkQXQ/LnRvRGF0ZSgpLFxuICAgICAgICB9O1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFVwZGF0ZSBjYWNoZVxuICAgICAgY29tcGFueUNhY2hlID0ge1xuICAgICAgICBjb21wYW5pZXMsXG4gICAgICAgIGxhc3RVcGRhdGVkOiBub3csXG4gICAgICAgIGlzTG9hZGVkOiB0cnVlXG4gICAgICB9O1xuXG4gICAgICBjb25zb2xlLmxvZyhgTG9hZGVkICR7Y29tcGFuaWVzLmxlbmd0aH0gY29tcGFuaWVzYCk7XG4gICAgICByZXR1cm4gY29tcGFuaWVzO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2FkaW5nIGNvbXBhbmllczonLCBlcnJvcik7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNlYXJjaCBjb21wYW5pZXMgd2l0aCBvcHRpbWl6ZWQgY2FjaGluZ1xuICAgKi9cbiAgYXN5bmMgc2VhcmNoQ29tcGFuaWVzKHF1ZXJ5OiBzdHJpbmcsIGxpbWl0OiBudW1iZXIgPSAxMCk6IFByb21pc2U8Q29tcGFueVtdPiB7XG4gICAgaWYgKCFxdWVyeS50cmltKCkpIHJldHVybiBbXTtcbiAgICBcbiAgICBjb25zdCBjb21wYW5pZXMgPSBhd2FpdCB0aGlzLmxvYWRBbGxDb21wYW5pZXMoKTtcbiAgICBjb25zdCBub3JtYWxpemVkUXVlcnkgPSBub3JtYWxpemVDb21wYW55TmFtZShxdWVyeSk7XG4gICAgXG4gICAgY29uc3QgcmVzdWx0czogU2VhcmNoUmVzdWx0W10gPSBbXTtcbiAgICBcbiAgICBmb3IgKGNvbnN0IGNvbXBhbnkgb2YgY29tcGFuaWVzKSB7XG4gICAgICBsZXQgYmVzdFNjb3JlID0gMDtcbiAgICAgIGxldCBtYXRjaFR5cGU6ICdleGFjdCcgfCAncGFydGlhbCcgfCAnZnV6enknIHwgJ2FsaWFzJyA9ICdmdXp6eSc7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGV4YWN0IG1hdGNoZXMgZmlyc3RcbiAgICAgIGlmIChjb21wYW55Lm5vcm1hbGl6ZWROYW1lID09PSBub3JtYWxpemVkUXVlcnkpIHtcbiAgICAgICAgYmVzdFNjb3JlID0gMS4wO1xuICAgICAgICBtYXRjaFR5cGUgPSAnZXhhY3QnO1xuICAgICAgfSBlbHNlIGlmIChjb21wYW55Lm5hbWUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhxdWVyeS50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgICBiZXN0U2NvcmUgPSAwLjk7XG4gICAgICAgIG1hdGNoVHlwZSA9ICdwYXJ0aWFsJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENoZWNrIGFsaWFzZXNcbiAgICAgICAgZm9yIChjb25zdCBhbGlhcyBvZiBjb21wYW55LmFsaWFzZXMpIHtcbiAgICAgICAgICBjb25zdCBhbGlhc05vcm1hbGl6ZWQgPSBub3JtYWxpemVDb21wYW55TmFtZShhbGlhcyk7XG4gICAgICAgICAgaWYgKGFsaWFzTm9ybWFsaXplZCA9PT0gbm9ybWFsaXplZFF1ZXJ5KSB7XG4gICAgICAgICAgICBiZXN0U2NvcmUgPSAwLjg7XG4gICAgICAgICAgICBtYXRjaFR5cGUgPSAnYWxpYXMnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBJZiBubyBleGFjdCBtYXRjaGVzLCB0cnkgZnV6enkgbWF0Y2hpbmdcbiAgICAgICAgaWYgKGJlc3RTY29yZSA9PT0gMCkge1xuICAgICAgICAgIGNvbnN0IHNpbWlsYXJpdHkgPSBjYWxjdWxhdGVTaW1pbGFyaXR5KG5vcm1hbGl6ZWRRdWVyeSwgY29tcGFueS5ub3JtYWxpemVkTmFtZSk7XG4gICAgICAgICAgaWYgKHNpbWlsYXJpdHkgPiAwLjcpIHtcbiAgICAgICAgICAgIGJlc3RTY29yZSA9IHNpbWlsYXJpdHk7XG4gICAgICAgICAgICBtYXRjaFR5cGUgPSAnZnV6enknO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAoYmVzdFNjb3JlID4gMCkge1xuICAgICAgICByZXN1bHRzLnB1c2goeyBjb21wYW55LCByZWxldmFuY2VTY29yZTogYmVzdFNjb3JlLCBtYXRjaFR5cGUgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIFNvcnQgYnkgcmVsZXZhbmNlIGFuZCByZXR1cm4gdG9wIHJlc3VsdHNcbiAgICByZXR1cm4gcmVzdWx0c1xuICAgICAgLnNvcnQoKGEsIGIpID0+IGIucmVsZXZhbmNlU2NvcmUgLSBhLnJlbGV2YW5jZVNjb3JlKVxuICAgICAgLnNsaWNlKDAsIGxpbWl0KVxuICAgICAgLm1hcChyZXN1bHQgPT4gcmVzdWx0LmNvbXBhbnkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmQgb3IgY3JlYXRlIGNvbXBhbnkgd2l0aCBjYWNoaW5nXG4gICAqL1xuICBhc3luYyBmaW5kT3JDcmVhdGVDb21wYW55KGNvbXBhbnlOYW1lOiBzdHJpbmcpOiBQcm9taXNlPENvbXBhbnk+IHtcbiAgICBpZiAoIWNvbXBhbnlOYW1lLnRyaW0oKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb21wYW55IG5hbWUgY2Fubm90IGJlIGVtcHR5Jyk7XG4gICAgfVxuICAgIFxuICAgIC8vIEZpcnN0IHRyeSB0byBmaW5kIGV4aXN0aW5nIGNvbXBhbnlcbiAgICBjb25zdCBzZWFyY2hSZXN1bHRzID0gYXdhaXQgdGhpcy5zZWFyY2hDb21wYW5pZXMoY29tcGFueU5hbWUsIDEpO1xuICAgIGlmIChzZWFyY2hSZXN1bHRzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGJlc3RNYXRjaCA9IHNlYXJjaFJlc3VsdHNbMF07XG4gICAgICBjb25zdCBzaW1pbGFyaXR5ID0gY2FsY3VsYXRlU2ltaWxhcml0eShcbiAgICAgICAgbm9ybWFsaXplQ29tcGFueU5hbWUoY29tcGFueU5hbWUpLCBcbiAgICAgICAgYmVzdE1hdGNoLm5vcm1hbGl6ZWROYW1lXG4gICAgICApO1xuICAgICAgXG4gICAgICAvLyBJZiBzaW1pbGFyaXR5IGlzIGhpZ2ggZW5vdWdoLCByZXR1cm4gZXhpc3RpbmcgY29tcGFueVxuICAgICAgaWYgKHNpbWlsYXJpdHkgPiAwLjgpIHtcbiAgICAgICAgcmV0dXJuIGJlc3RNYXRjaDtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gQ3JlYXRlIG5ldyBjb21wYW55IGlmIG5vIGdvb2QgbWF0Y2ggZm91bmRcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVDb21wYW55KGNvbXBhbnlOYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgbmV3IGNvbXBhbnlcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgY3JlYXRlQ29tcGFueShjb21wYW55TmFtZTogc3RyaW5nKTogUHJvbWlzZTxDb21wYW55PiB7XG4gICAgaWYgKCF0aGlzLmRiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpcmViYXNlIG5vdCBpbml0aWFsaXplZCcpO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBub3JtYWxpemVkTmFtZSA9IG5vcm1hbGl6ZUNvbXBhbnlOYW1lKGNvbXBhbnlOYW1lKTtcbiAgICBjb25zdCBhbGlhc2VzID0gZ2VuZXJhdGVBbGlhc2VzKGNvbXBhbnlOYW1lKTtcbiAgICBcbiAgICBjb25zdCBjb21wYW55RGF0YSA9IHtcbiAgICAgIG5hbWU6IGNvbXBhbnlOYW1lLnRyaW0oKSxcbiAgICAgIG5vcm1hbGl6ZWROYW1lLFxuICAgICAgYWxpYXNlcyxcbiAgICAgIHN1Ym1pc3Npb25Db3VudDogMCxcbiAgICAgIGNvbW1vbkZsYWdzOiBbXSxcbiAgICAgIGF2ZXJhZ2VGbGFnQ291bnQ6IDAsXG4gICAgICBzZXZlcml0eVRyZW5kczogeyBsaWdodDogMCwgbWVkaXVtOiAwIH0sXG4gICAgICBjcmVhdGVkQXQ6IHNlcnZlclRpbWVzdGFtcCgpLFxuICAgICAgdXBkYXRlZEF0OiBzZXJ2ZXJUaW1lc3RhbXAoKSxcbiAgICB9O1xuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCBkb2NSZWYgPSBhd2FpdCBhZGREb2MoY29sbGVjdGlvbih0aGlzLmRiLCAnY29tcGFuaWVzJyksIGNvbXBhbnlEYXRhKTtcbiAgICAgIFxuICAgICAgY29uc3QgbmV3Q29tcGFueTogQ29tcGFueSA9IHtcbiAgICAgICAgaWQ6IGRvY1JlZi5pZCxcbiAgICAgICAgLi4uY29tcGFueURhdGEsXG4gICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLFxuICAgICAgfTtcbiAgICAgIFxuICAgICAgLy8gQWRkIHRvIGNhY2hlXG4gICAgICBjb21wYW55Q2FjaGUuY29tcGFuaWVzLnB1c2gobmV3Q29tcGFueSk7XG4gICAgICBcbiAgICAgIHJldHVybiBuZXdDb21wYW55O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyBjb21wYW55OicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgY29tcGFueSB3aXRoIHN1Ym1pc3Npb24gZGF0YVxuICAgKi9cbiAgYXN5bmMgdXBkYXRlQ29tcGFueVdpdGhTdWJtaXNzaW9uKFxuICAgIGNvbXBhbnlJZDogc3RyaW5nLCBcbiAgICBzdWJtaXNzaW9uRGF0YToge1xuICAgICAgbWFya2VkRmxhZ3M6IHN0cmluZ1tdO1xuICAgICAgc2V2ZXJpdHlCcmVha2Rvd246IHsgbGlnaHQ6IG51bWJlcjsgbWVkaXVtOiBudW1iZXIgfTtcbiAgICB9XG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICghdGhpcy5kYikge1xuICAgICAgY29uc29sZS53YXJuKCdGaXJlYmFzZSBub3QgaW5pdGlhbGl6ZWQuIFNraXBwaW5nIGNvbXBhbnkgdXBkYXRlLicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgZG9jUmVmID0gZG9jKHRoaXMuZGIsICdjb21wYW5pZXMnLCBjb21wYW55SWQpO1xuICAgICAgXG4gICAgICAvLyBHZXQgY3VycmVudCBjb21wYW55IGRhdGFcbiAgICAgIGNvbnN0IGNvbXBhbnkgPSBjb21wYW55Q2FjaGUuY29tcGFuaWVzLmZpbmQoYyA9PiBjLmlkID09PSBjb21wYW55SWQpO1xuICAgICAgaWYgKCFjb21wYW55KSB7XG4gICAgICAgIGNvbnNvbGUud2FybignQ29tcGFueSBub3QgZm91bmQgaW4gY2FjaGUgZm9yIHVwZGF0ZScpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IHVwZGF0ZWREYXRhID0ge1xuICAgICAgICBzdWJtaXNzaW9uQ291bnQ6IGNvbXBhbnkuc3VibWlzc2lvbkNvdW50ICsgMSxcbiAgICAgICAgY29tbW9uRmxhZ3M6IEFycmF5LmZyb20obmV3IFNldChbLi4uY29tcGFueS5jb21tb25GbGFncywgLi4uc3VibWlzc2lvbkRhdGEubWFya2VkRmxhZ3NdKSksXG4gICAgICAgIGF2ZXJhZ2VGbGFnQ291bnQ6IChjb21wYW55LmF2ZXJhZ2VGbGFnQ291bnQgKiBjb21wYW55LnN1Ym1pc3Npb25Db3VudCArIHN1Ym1pc3Npb25EYXRhLm1hcmtlZEZsYWdzLmxlbmd0aCkgLyAoY29tcGFueS5zdWJtaXNzaW9uQ291bnQgKyAxKSxcbiAgICAgICAgc2V2ZXJpdHlUcmVuZHM6IHtcbiAgICAgICAgICBsaWdodDogY29tcGFueS5zZXZlcml0eVRyZW5kcy5saWdodCArIHN1Ym1pc3Npb25EYXRhLnNldmVyaXR5QnJlYWtkb3duLmxpZ2h0LFxuICAgICAgICAgIG1lZGl1bTogY29tcGFueS5zZXZlcml0eVRyZW5kcy5tZWRpdW0gKyBzdWJtaXNzaW9uRGF0YS5zZXZlcml0eUJyZWFrZG93bi5tZWRpdW1cbiAgICAgICAgfSxcbiAgICAgICAgbGFzdFN1Ym1pc3Npb246IHNlcnZlclRpbWVzdGFtcCgpLFxuICAgICAgICB1cGRhdGVkQXQ6IHNlcnZlclRpbWVzdGFtcCgpLFxuICAgICAgfTtcbiAgICAgIFxuICAgICAgYXdhaXQgdXBkYXRlRG9jKGRvY1JlZiwgdXBkYXRlZERhdGEpO1xuICAgICAgXG4gICAgICAvLyBVcGRhdGUgY2FjaGVcbiAgICAgIGNvbnN0IGNhY2hlSW5kZXggPSBjb21wYW55Q2FjaGUuY29tcGFuaWVzLmZpbmRJbmRleChjID0+IGMuaWQgPT09IGNvbXBhbnlJZCk7XG4gICAgICBpZiAoY2FjaGVJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgY29tcGFueUNhY2hlLmNvbXBhbmllc1tjYWNoZUluZGV4XSA9IHtcbiAgICAgICAgICAuLi5jb21wYW55LFxuICAgICAgICAgIC4uLnVwZGF0ZWREYXRhLFxuICAgICAgICAgIGxhc3RTdWJtaXNzaW9uOiBuZXcgRGF0ZSgpLFxuICAgICAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBkYXRpbmcgY29tcGFueSB3aXRoIHN1Ym1pc3Npb246JywgZXJyb3IpO1xuICAgICAgLy8gRG9uJ3QgdGhyb3cgZXJyb3IgLSBjb21wYW55IHVwZGF0ZSBpcyBub3QgY3JpdGljYWxcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVmcmVzaCBjb21wYW5pZXMgY2FjaGVcbiAgICovXG4gIGFzeW5jIHJlZnJlc2hDb21wYW5pZXMoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29tcGFueUNhY2hlID0ge1xuICAgICAgY29tcGFuaWVzOiBbXSxcbiAgICAgIGxhc3RVcGRhdGVkOiAwLFxuICAgICAgaXNMb2FkZWQ6IGZhbHNlXG4gICAgfTtcbiAgICBhd2FpdCB0aGlzLmxvYWRBbGxDb21wYW5pZXMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYWxsIGNvbXBhbmllcyAoY2FjaGVkKVxuICAgKi9cbiAgYXN5bmMgZ2V0QWxsQ29tcGFuaWVzKCk6IFByb21pc2U8Q29tcGFueVtdPiB7XG4gICAgcmV0dXJuIHRoaXMubG9hZEFsbENvbXBhbmllcygpO1xuICB9XG59XG5cbi8vIEV4cG9ydCBzaW5nbGV0b24gaW5zdGFuY2VcbmV4cG9ydCBjb25zdCBjb21wYW55U2VydmljZSA9IENvbXBhbnlTZXJ2aWNlLmdldEluc3RhbmNlKCk7XG5cbi8vIExlZ2FjeSBmdW5jdGlvbnMgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbmV4cG9ydCBjb25zdCBnZXRDb21wYW55SW5zaWdodHMgPSBhc3luYyAoY29tcGFueU5hbWU6IHN0cmluZykgPT4ge1xuICBjb25zdCBjb21wYW5pZXMgPSBhd2FpdCBjb21wYW55U2VydmljZS5zZWFyY2hDb21wYW5pZXMoY29tcGFueU5hbWUsIDEpO1xuICByZXR1cm4gY29tcGFuaWVzLmxlbmd0aCA+IDAgPyBjb21wYW5pZXNbMF0gOiBudWxsO1xufTtcblxuZXhwb3J0IGNvbnN0IHVwZGF0ZUNvbXBhbnlJbnNpZ2h0cyA9IGFzeW5jIChjb21wYW55TmFtZTogc3RyaW5nLCBzdWJtaXNzaW9uRGF0YTogYW55KSA9PiB7XG4gIGNvbnN0IGNvbXBhbmllcyA9IGF3YWl0IGNvbXBhbnlTZXJ2aWNlLnNlYXJjaENvbXBhbmllcyhjb21wYW55TmFtZSwgMSk7XG4gIGlmIChjb21wYW5pZXMubGVuZ3RoID4gMCkge1xuICAgIGF3YWl0IGNvbXBhbnlTZXJ2aWNlLnVwZGF0ZUNvbXBhbnlXaXRoU3VibWlzc2lvbihjb21wYW5pZXNbMF0uaWQsIHN1Ym1pc3Npb25EYXRhKTtcbiAgfVxufTsgIl0sIm5hbWVzIjpbImNvbGxlY3Rpb24iLCJnZXREb2NzIiwiYWRkRG9jIiwidXBkYXRlRG9jIiwiZG9jIiwic2VydmVyVGltZXN0YW1wIiwiZ2V0RmlyZXN0b3JlREIiLCJDQUNIRV9UVEwiLCJjb21wYW55Q2FjaGUiLCJjb21wYW5pZXMiLCJsYXN0VXBkYXRlZCIsImlzTG9hZGVkIiwibm9ybWFsaXplQ29tcGFueU5hbWUiLCJpbnB1dCIsInRyaW0iLCJ0b0xvd2VyQ2FzZSIsInJlcGxhY2UiLCJnZW5lcmF0ZUFsaWFzZXMiLCJuYW1lIiwid2Vic2l0ZSIsImFsaWFzZXMiLCJwdXNoIiwibmFtZUNsZWFuIiwidXJsIiwiVVJMIiwiZG9tYWluIiwiaG9zdG5hbWUiLCJzdGFydHNXaXRoIiwic3Vic3RyaW5nIiwiQXJyYXkiLCJmcm9tIiwiU2V0IiwiZmlsdGVyIiwiYWxpYXMiLCJjYWxjdWxhdGVTaW1pbGFyaXR5Iiwic3RyMSIsInN0cjIiLCJtYXRyaXgiLCJsZW4xIiwibGVuZ3RoIiwibGVuMiIsImkiLCJqIiwiY2hhckF0IiwiTWF0aCIsIm1pbiIsIm1heExlbmd0aCIsIm1heCIsIkNvbXBhbnlTZXJ2aWNlIiwiZ2V0SW5zdGFuY2UiLCJpbnN0YW5jZSIsImxvYWRBbGxDb21wYW5pZXMiLCJub3ciLCJEYXRlIiwiZGIiLCJjb25zb2xlIiwid2FybiIsImNvbXBhbmllc1JlZiIsInNuYXBzaG90IiwiZG9jcyIsIm1hcCIsImRhdGEiLCJpZCIsIm5vcm1hbGl6ZWROYW1lIiwibG9jYXRpb24iLCJpbmR1c3RyeSIsImNvbXBhbnlfc2l6ZSIsImNvbXBhbnlfdHlwZSIsImZvdW5kZWRfeWVhciIsInNwZWNpYWxpdGllcyIsImxvY2F0aW9ucyIsInN1Ym1pc3Npb25Db3VudCIsImxhc3RTdWJtaXNzaW9uIiwidG9EYXRlIiwiY29tbW9uRmxhZ3MiLCJhdmVyYWdlRmxhZ0NvdW50Iiwic2V2ZXJpdHlUcmVuZHMiLCJsaWdodCIsIm1lZGl1bSIsImNyZWF0ZWRBdCIsInVwZGF0ZWRBdCIsImxvZyIsImVycm9yIiwic2VhcmNoQ29tcGFuaWVzIiwicXVlcnkiLCJsaW1pdCIsIm5vcm1hbGl6ZWRRdWVyeSIsInJlc3VsdHMiLCJjb21wYW55IiwiYmVzdFNjb3JlIiwibWF0Y2hUeXBlIiwiaW5jbHVkZXMiLCJhbGlhc05vcm1hbGl6ZWQiLCJzaW1pbGFyaXR5IiwicmVsZXZhbmNlU2NvcmUiLCJzb3J0IiwiYSIsImIiLCJzbGljZSIsInJlc3VsdCIsImZpbmRPckNyZWF0ZUNvbXBhbnkiLCJjb21wYW55TmFtZSIsIkVycm9yIiwic2VhcmNoUmVzdWx0cyIsImJlc3RNYXRjaCIsImNyZWF0ZUNvbXBhbnkiLCJjb21wYW55RGF0YSIsImRvY1JlZiIsIm5ld0NvbXBhbnkiLCJ1cGRhdGVDb21wYW55V2l0aFN1Ym1pc3Npb24iLCJjb21wYW55SWQiLCJzdWJtaXNzaW9uRGF0YSIsImZpbmQiLCJjIiwidXBkYXRlZERhdGEiLCJtYXJrZWRGbGFncyIsInNldmVyaXR5QnJlYWtkb3duIiwiY2FjaGVJbmRleCIsImZpbmRJbmRleCIsInJlZnJlc2hDb21wYW5pZXMiLCJnZXRBbGxDb21wYW5pZXMiLCJjb21wYW55U2VydmljZSIsImdldENvbXBhbnlJbnNpZ2h0cyIsInVwZGF0ZUNvbXBhbnlJbnNpZ2h0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/companyUtils.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./lib/firebase.ts":
/*!*************************!*\
  !*** ./lib/firebase.ts ***!
  \*************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   app: function() { return /* binding */ app; },\n/* harmony export */   db: function() { return /* binding */ db; },\n/* harmony export */   generateSessionId: function() { return /* binding */ generateSessionId; },\n/* harmony export */   getCompanyInsights: function() { return /* binding */ getCompanyInsights; },\n/* harmony export */   getFirebaseApp: function() { return /* binding */ getFirebaseApp; },\n/* harmony export */   getFirestoreDB: function() { return /* binding */ getFirestoreDB; },\n/* harmony export */   hashIP: function() { return /* binding */ hashIP; },\n/* harmony export */   initializeFirebase: function() { return /* binding */ initializeFirebase; },\n/* harmony export */   normalizeCompanyName: function() { return /* binding */ normalizeCompanyName; },\n/* harmony export */   submitInterviewCheckup: function() { return /* binding */ submitInterviewCheckup; },\n/* harmony export */   updateCompanyInsights: function() { return /* binding */ updateCompanyInsights; },\n/* harmony export */   validateFirebaseConfig: function() { return /* binding */ validateFirebaseConfig; }\n/* harmony export */ });\n/* harmony import */ var firebase_app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! firebase/app */ \"(app-pages-browser)/./node_modules/firebase/app/dist/esm/index.esm.js\");\n/* harmony import */ var firebase_firestore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! firebase/firestore */ \"(app-pages-browser)/./node_modules/firebase/firestore/dist/esm/index.esm.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n\n\n// Firebase configuration\nconst firebaseConfig = {\n    apiKey: \"AIzaSyCTMqWzORaG1eK0Tp-T8e0h39rDJpLMPPQ\",\n    authDomain: \"did-i-dodge-a-bullet.firebaseapp.com\",\n    projectId: \"did-i-dodge-a-bullet\",\n    storageBucket: \"did-i-dodge-a-bullet.firebasestorage.app\",\n    messagingSenderId: \"190454478964\",\n    appId: \"1:190454478964:web:8b54426780fe1792627921\"\n};\n// Singleton pattern to prevent multiple initializations\nlet firebaseApp = null;\nlet firestoreDB = null;\n// Initialize Firebase only once\nconst initializeFirebase = ()=>{\n    if (!firebaseApp) {\n        // Check if Firebase is already initialized\n        const existingApps = (0,firebase_app__WEBPACK_IMPORTED_MODULE_0__.getApps)();\n        if (existingApps.length > 0) {\n            firebaseApp = existingApps[0];\n        } else {\n            firebaseApp = (0,firebase_app__WEBPACK_IMPORTED_MODULE_0__.initializeApp)(firebaseConfig);\n        }\n    }\n    if (!firestoreDB) {\n        firestoreDB = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getFirestore)(firebaseApp);\n    }\n    return {\n        app: firebaseApp,\n        db: firestoreDB\n    };\n};\n// Get Firebase instances\nconst getFirebaseApp = ()=>{\n    if (!firebaseApp) {\n        const { app } = initializeFirebase();\n        return app;\n    }\n    return firebaseApp;\n};\nconst getFirestoreDB = ()=>{\n    if (!firestoreDB) {\n        const { db } = initializeFirebase();\n        return db;\n    }\n    return firestoreDB;\n};\n// Export for backward compatibility\nconst db = getFirestoreDB();\nconst app = getFirebaseApp();\n// Validate configuration\nconst validateFirebaseConfig = ()=>{\n    const requiredKeys = [\n        \"NEXT_PUBLIC_FIREBASE_API_KEY\",\n        \"NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN\",\n        \"NEXT_PUBLIC_FIREBASE_PROJECT_ID\",\n        \"NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET\",\n        \"NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID\",\n        \"NEXT_PUBLIC_FIREBASE_APP_ID\"\n    ];\n    const missingKeys = requiredKeys.filter((key)=>!process.env[key]);\n    if (missingKeys.length > 0) {\n        console.error(\"Missing Firebase configuration keys:\", missingKeys);\n        return false;\n    }\n    return true;\n};\n// Initialize on module load\nif (true) {\n    // Only initialize on client side\n    try {\n        if (validateFirebaseConfig()) {\n            initializeFirebase();\n            console.log(\"✅ Firebase initialized successfully\");\n        } else {\n            console.warn(\"⚠️ Firebase configuration incomplete\");\n        }\n    } catch (error) {\n        console.error(\"❌ Firebase initialization failed:\", error);\n    }\n}\n// Database functions\nconst submitInterviewCheckup = async (data)=>{\n    if (!firestoreDB) {\n        throw new Error(\"Firebase not initialized. Please set up your Firebase configuration.\");\n    }\n    try {\n        const submissionData = {\n            ...data,\n            timestamp: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)()\n        };\n        const docRef = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.addDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(firestoreDB, \"submissions\"), submissionData);\n        // Update company insights if company name provided\n        if (data.companyName) {\n            await updateCompanyInsights(data.companyName, submissionData);\n        }\n        return docRef.id;\n    } catch (error) {\n        console.error(\"Error submitting interview checkup:\", error);\n        throw error;\n    }\n};\nconst updateCompanyInsights = async (companyName, submissionData)=>{\n    if (!firestoreDB) {\n        console.warn(\"Firebase not initialized. Skipping company insights update.\");\n        return;\n    }\n    try {\n        const normalizedCompanyName = normalizeCompanyName(companyName);\n        // Check if company insights already exist\n        const companyQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(firestoreDB, \"company_insights\"), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)(\"companyName\", \"==\", normalizedCompanyName));\n        const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(companyQuery);\n        if (!querySnapshot.empty) {\n            // Update existing company insights\n            const docRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(firestoreDB, \"company_insights\", querySnapshot.docs[0].id);\n            const existingData = querySnapshot.docs[0].data();\n            const updatedData = {\n                totalSubmissions: existingData.totalSubmissions + 1,\n                commonFlags: Array.from(new Set([\n                    ...existingData.commonFlags,\n                    ...submissionData.markedFlags\n                ])),\n                averageFlagCount: (existingData.averageFlagCount * existingData.totalSubmissions + submissionData.markedFlags.length) / (existingData.totalSubmissions + 1),\n                severityTrends: {\n                    light: existingData.severityTrends.light + submissionData.severityBreakdown.light,\n                    medium: existingData.severityTrends.medium + submissionData.severityBreakdown.medium\n                },\n                lastUpdated: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)()\n            };\n            await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.updateDoc)(docRef, updatedData);\n        } else {\n            // Create new company insights\n            await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.addDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(firestoreDB, \"company_insights\"), {\n                companyName: normalizedCompanyName,\n                totalSubmissions: 1,\n                commonFlags: submissionData.markedFlags,\n                averageFlagCount: submissionData.markedFlags.length,\n                severityTrends: submissionData.severityBreakdown,\n                lastUpdated: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)()\n            });\n        }\n    } catch (error) {\n        console.error(\"Error updating company insights:\", error);\n    // Don't throw error - company insights update is not critical\n    }\n};\nconst getCompanyInsights = async (companyName)=>{\n    if (!firestoreDB) {\n        console.warn(\"Firebase not initialized. Cannot get company insights.\");\n        return null;\n    }\n    try {\n        const normalizedCompanyName = normalizeCompanyName(companyName);\n        const companyQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(firestoreDB, \"company_insights\"), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)(\"companyName\", \"==\", normalizedCompanyName));\n        const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(companyQuery);\n        if (!querySnapshot.empty) {\n            return querySnapshot.docs[0].data();\n        }\n        return null;\n    } catch (error) {\n        console.error(\"Error getting company insights:\", error);\n        return null;\n    }\n};\n// Utility functions\nconst normalizeCompanyName = (input)=>{\n    return input.trim().toLowerCase().replace(/\\s+/g, \" \").replace(/[^\\w\\s-]/g, \"\").replace(/\\b(inc|corp|llc|ltd|co|company)\\b/g, \"\").trim();\n};\nconst generateSessionId = ()=>{\n    return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);\n};\nconst hashIP = async (ip)=>{\n    const encoder = new TextEncoder();\n    const data = encoder.encode(ip);\n    const hashBuffer = await crypto.subtle.digest(\"SHA-256\", data);\n    const hashArray = Array.from(new Uint8Array(hashBuffer));\n    return hashArray.map((b)=>b.toString(16).padStart(2, \"0\")).join(\"\");\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RyxvQkFBb0I7SUFDL0IsT0FBT0MsS0FBS0MsTUFBTSxHQUFHQyxRQUFRLENBQUMsSUFBSUMsU0FBUyxDQUFDLEdBQUcsTUFBTUgsS0FBS0MsTUFBTSxHQUFHQyxRQUFRLENBQUMsSUFBSUMsU0FBUyxDQUFDLEdBQUc7QUFDL0YsRUFBRTtBQUVLLE1BQU1DLFNBQVMsT0FBT0M7SUFDM0IsTUFBTUMsVUFBVSxJQUFJQztJQUNwQixNQUFNekMsT0FBT3dDLFFBQVFFLE1BQU0sQ0FBQ0g7SUFDNUIsTUFBTUksYUFBYSxNQUFNQyxPQUFPQyxNQUFNLENBQUNDLE1BQU0sQ0FBQyxXQUFXOUM7SUFDekQsTUFBTStDLFlBQVk3QixNQUFNQyxJQUFJLENBQUMsSUFBSTZCLFdBQVdMO0lBQzVDLE9BQU9JLFVBQVVFLEdBQUcsQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRWQsUUFBUSxDQUFDLElBQUllLFFBQVEsQ0FBQyxHQUFHLE1BQU1DLElBQUksQ0FBQztBQUNsRSxFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi9maXJlYmFzZS50cz81ZDIxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGluaXRpYWxpemVBcHAsIGdldEFwcHMsIEZpcmViYXNlQXBwIH0gZnJvbSAnZmlyZWJhc2UvYXBwJztcclxuaW1wb3J0IHsgXHJcbiAgZ2V0RmlyZXN0b3JlLCBcclxuICBGaXJlc3RvcmUsIFxyXG4gIGNvbGxlY3Rpb24sIFxyXG4gIGFkZERvYywgXHJcbiAgdXBkYXRlRG9jLCBcclxuICBkb2MsIFxyXG4gIGdldERvY3MsIFxyXG4gIHF1ZXJ5LCBcclxuICB3aGVyZSwgXHJcbiAgc2VydmVyVGltZXN0YW1wIFxyXG59IGZyb20gJ2ZpcmViYXNlL2ZpcmVzdG9yZSc7XHJcblxyXG4vLyBGaXJlYmFzZSBjb25maWd1cmF0aW9uXHJcbmNvbnN0IGZpcmViYXNlQ29uZmlnID0ge1xyXG4gIGFwaUtleTogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfRklSRUJBU0VfQVBJX0tFWSxcclxuICBhdXRoRG9tYWluOiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19GSVJFQkFTRV9BVVRIX0RPTUFJTixcclxuICBwcm9qZWN0SWQ6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0ZJUkVCQVNFX1BST0pFQ1RfSUQsXHJcbiAgc3RvcmFnZUJ1Y2tldDogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfRklSRUJBU0VfU1RPUkFHRV9CVUNLRVQsXHJcbiAgbWVzc2FnaW5nU2VuZGVySWQ6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0ZJUkVCQVNFX01FU1NBR0lOR19TRU5ERVJfSUQsXHJcbiAgYXBwSWQ6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0ZJUkVCQVNFX0FQUF9JRCxcclxufTtcclxuXHJcbi8vIFNpbmdsZXRvbiBwYXR0ZXJuIHRvIHByZXZlbnQgbXVsdGlwbGUgaW5pdGlhbGl6YXRpb25zXHJcbmxldCBmaXJlYmFzZUFwcDogRmlyZWJhc2VBcHAgfCBudWxsID0gbnVsbDtcclxubGV0IGZpcmVzdG9yZURCOiBGaXJlc3RvcmUgfCBudWxsID0gbnVsbDtcclxuXHJcbi8vIEluaXRpYWxpemUgRmlyZWJhc2Ugb25seSBvbmNlXHJcbmV4cG9ydCBjb25zdCBpbml0aWFsaXplRmlyZWJhc2UgPSAoKTogeyBhcHA6IEZpcmViYXNlQXBwOyBkYjogRmlyZXN0b3JlIH0gPT4ge1xyXG4gIGlmICghZmlyZWJhc2VBcHApIHtcclxuICAgIC8vIENoZWNrIGlmIEZpcmViYXNlIGlzIGFscmVhZHkgaW5pdGlhbGl6ZWRcclxuICAgIGNvbnN0IGV4aXN0aW5nQXBwcyA9IGdldEFwcHMoKTtcclxuICAgIGlmIChleGlzdGluZ0FwcHMubGVuZ3RoID4gMCkge1xyXG4gICAgICBmaXJlYmFzZUFwcCA9IGV4aXN0aW5nQXBwc1swXTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGZpcmViYXNlQXBwID0gaW5pdGlhbGl6ZUFwcChmaXJlYmFzZUNvbmZpZyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpZiAoIWZpcmVzdG9yZURCKSB7XHJcbiAgICBmaXJlc3RvcmVEQiA9IGdldEZpcmVzdG9yZShmaXJlYmFzZUFwcCk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4geyBhcHA6IGZpcmViYXNlQXBwLCBkYjogZmlyZXN0b3JlREIgfTtcclxufTtcclxuXHJcbi8vIEdldCBGaXJlYmFzZSBpbnN0YW5jZXNcclxuZXhwb3J0IGNvbnN0IGdldEZpcmViYXNlQXBwID0gKCk6IEZpcmViYXNlQXBwID0+IHtcclxuICBpZiAoIWZpcmViYXNlQXBwKSB7XHJcbiAgICBjb25zdCB7IGFwcCB9ID0gaW5pdGlhbGl6ZUZpcmViYXNlKCk7XHJcbiAgICByZXR1cm4gYXBwO1xyXG4gIH1cclxuICByZXR1cm4gZmlyZWJhc2VBcHA7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZ2V0RmlyZXN0b3JlREIgPSAoKTogRmlyZXN0b3JlID0+IHtcclxuICBpZiAoIWZpcmVzdG9yZURCKSB7XHJcbiAgICBjb25zdCB7IGRiIH0gPSBpbml0aWFsaXplRmlyZWJhc2UoKTtcclxuICAgIHJldHVybiBkYjtcclxuICB9XHJcbiAgcmV0dXJuIGZpcmVzdG9yZURCO1xyXG59O1xyXG5cclxuLy8gRXhwb3J0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XHJcbmV4cG9ydCBjb25zdCBkYiA9IGdldEZpcmVzdG9yZURCKCk7XHJcbmV4cG9ydCBjb25zdCBhcHAgPSBnZXRGaXJlYmFzZUFwcCgpO1xyXG5cclxuLy8gVmFsaWRhdGUgY29uZmlndXJhdGlvblxyXG5leHBvcnQgY29uc3QgdmFsaWRhdGVGaXJlYmFzZUNvbmZpZyA9ICgpOiBib29sZWFuID0+IHtcclxuICBjb25zdCByZXF1aXJlZEtleXMgPSBbXHJcbiAgICAnTkVYVF9QVUJMSUNfRklSRUJBU0VfQVBJX0tFWScsXHJcbiAgICAnTkVYVF9QVUJMSUNfRklSRUJBU0VfQVVUSF9ET01BSU4nLFxyXG4gICAgJ05FWFRfUFVCTElDX0ZJUkVCQVNFX1BST0pFQ1RfSUQnLFxyXG4gICAgJ05FWFRfUFVCTElDX0ZJUkVCQVNFX1NUT1JBR0VfQlVDS0VUJyxcclxuICAgICdORVhUX1BVQkxJQ19GSVJFQkFTRV9NRVNTQUdJTkdfU0VOREVSX0lEJyxcclxuICAgICdORVhUX1BVQkxJQ19GSVJFQkFTRV9BUFBfSUQnLFxyXG4gIF07XHJcblxyXG4gIGNvbnN0IG1pc3NpbmdLZXlzID0gcmVxdWlyZWRLZXlzLmZpbHRlcihrZXkgPT4gIXByb2Nlc3MuZW52W2tleV0pO1xyXG4gIFxyXG4gIGlmIChtaXNzaW5nS2V5cy5sZW5ndGggPiAwKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdNaXNzaW5nIEZpcmViYXNlIGNvbmZpZ3VyYXRpb24ga2V5czonLCBtaXNzaW5nS2V5cyk7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdHJ1ZTtcclxufTtcclxuXHJcbi8vIEluaXRpYWxpemUgb24gbW9kdWxlIGxvYWRcclxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgLy8gT25seSBpbml0aWFsaXplIG9uIGNsaWVudCBzaWRlXHJcbiAgdHJ5IHtcclxuICAgIGlmICh2YWxpZGF0ZUZpcmViYXNlQ29uZmlnKCkpIHtcclxuICAgICAgaW5pdGlhbGl6ZUZpcmViYXNlKCk7XHJcbiAgICAgIGNvbnNvbGUubG9nKCfinIUgRmlyZWJhc2UgaW5pdGlhbGl6ZWQgc3VjY2Vzc2Z1bGx5Jyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zb2xlLndhcm4oJ+KaoO+4jyBGaXJlYmFzZSBjb25maWd1cmF0aW9uIGluY29tcGxldGUnKTtcclxuICAgIH1cclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcign4p2MIEZpcmViYXNlIGluaXRpYWxpemF0aW9uIGZhaWxlZDonLCBlcnJvcik7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBEYXRhYmFzZSB0eXBlc1xyXG5leHBvcnQgaW50ZXJmYWNlIEludGVydmlld1N1Ym1pc3Npb24ge1xyXG4gIGNvbXBhbnlOYW1lPzogc3RyaW5nIHwgbnVsbDtcclxuICBtYXJrZWRGbGFnczogc3RyaW5nW107XHJcbiAgdG90YWxGbGFnczogbnVtYmVyO1xyXG4gIHNldmVyaXR5QnJlYWtkb3duOiB7XHJcbiAgICBsaWdodDogbnVtYmVyO1xyXG4gICAgbWVkaXVtOiBudW1iZXI7XHJcbiAgfTtcclxuICB0aW1lc3RhbXA6IGFueTsgLy8gRmlyZXN0b3JlIHRpbWVzdGFtcFxyXG4gIHVzZXJBZ2VudD86IHN0cmluZztcclxuICBpcEhhc2g/OiBzdHJpbmc7XHJcbiAgc2Vzc2lvbklkOiBzdHJpbmc7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQ29tcGFueUluc2lnaHRzIHtcclxuICBjb21wYW55TmFtZTogc3RyaW5nO1xyXG4gIHRvdGFsU3VibWlzc2lvbnM6IG51bWJlcjtcclxuICBjb21tb25GbGFnczogc3RyaW5nW107XHJcbiAgYXZlcmFnZUZsYWdDb3VudDogbnVtYmVyO1xyXG4gIHNldmVyaXR5VHJlbmRzOiB7XHJcbiAgICBsaWdodDogbnVtYmVyO1xyXG4gICAgbWVkaXVtOiBudW1iZXI7XHJcbiAgfTtcclxuICBsYXN0VXBkYXRlZDogYW55OyAvLyBGaXJlc3RvcmUgdGltZXN0YW1wXHJcbn1cclxuXHJcbi8vIERhdGFiYXNlIGZ1bmN0aW9uc1xyXG5leHBvcnQgY29uc3Qgc3VibWl0SW50ZXJ2aWV3Q2hlY2t1cCA9IGFzeW5jIChkYXRhOiBPbWl0PEludGVydmlld1N1Ym1pc3Npb24sICd0aW1lc3RhbXAnPikgPT4ge1xyXG4gIGlmICghZmlyZXN0b3JlREIpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignRmlyZWJhc2Ugbm90IGluaXRpYWxpemVkLiBQbGVhc2Ugc2V0IHVwIHlvdXIgRmlyZWJhc2UgY29uZmlndXJhdGlvbi4nKTtcclxuICB9XHJcbiAgXHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHN1Ym1pc3Npb25EYXRhOiBJbnRlcnZpZXdTdWJtaXNzaW9uID0ge1xyXG4gICAgICAuLi5kYXRhLFxyXG4gICAgICB0aW1lc3RhbXA6IHNlcnZlclRpbWVzdGFtcCgpXHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBjb25zdCBkb2NSZWYgPSBhd2FpdCBhZGREb2MoY29sbGVjdGlvbihmaXJlc3RvcmVEQiwgJ3N1Ym1pc3Npb25zJyksIHN1Ym1pc3Npb25EYXRhKTtcclxuICAgIFxyXG4gICAgLy8gVXBkYXRlIGNvbXBhbnkgaW5zaWdodHMgaWYgY29tcGFueSBuYW1lIHByb3ZpZGVkXHJcbiAgICBpZiAoZGF0YS5jb21wYW55TmFtZSkge1xyXG4gICAgICBhd2FpdCB1cGRhdGVDb21wYW55SW5zaWdodHMoZGF0YS5jb21wYW55TmFtZSwgc3VibWlzc2lvbkRhdGEpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gZG9jUmVmLmlkO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzdWJtaXR0aW5nIGludGVydmlldyBjaGVja3VwOicsIGVycm9yKTtcclxuICAgIHRocm93IGVycm9yO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCB1cGRhdGVDb21wYW55SW5zaWdodHMgPSBhc3luYyAoY29tcGFueU5hbWU6IHN0cmluZywgc3VibWlzc2lvbkRhdGE6IEludGVydmlld1N1Ym1pc3Npb24pID0+IHtcclxuICBpZiAoIWZpcmVzdG9yZURCKSB7XHJcbiAgICBjb25zb2xlLndhcm4oJ0ZpcmViYXNlIG5vdCBpbml0aWFsaXplZC4gU2tpcHBpbmcgY29tcGFueSBpbnNpZ2h0cyB1cGRhdGUuJyk7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIFxyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBub3JtYWxpemVkQ29tcGFueU5hbWUgPSBub3JtYWxpemVDb21wYW55TmFtZShjb21wYW55TmFtZSk7XHJcbiAgICBcclxuICAgIC8vIENoZWNrIGlmIGNvbXBhbnkgaW5zaWdodHMgYWxyZWFkeSBleGlzdFxyXG4gICAgY29uc3QgY29tcGFueVF1ZXJ5ID0gcXVlcnkoXHJcbiAgICAgIGNvbGxlY3Rpb24oZmlyZXN0b3JlREIsICdjb21wYW55X2luc2lnaHRzJyksXHJcbiAgICAgIHdoZXJlKCdjb21wYW55TmFtZScsICc9PScsIG5vcm1hbGl6ZWRDb21wYW55TmFtZSlcclxuICAgICk7XHJcbiAgICBcclxuICAgIGNvbnN0IHF1ZXJ5U25hcHNob3QgPSBhd2FpdCBnZXREb2NzKGNvbXBhbnlRdWVyeSk7XHJcbiAgICBcclxuICAgIGlmICghcXVlcnlTbmFwc2hvdC5lbXB0eSkge1xyXG4gICAgICAvLyBVcGRhdGUgZXhpc3RpbmcgY29tcGFueSBpbnNpZ2h0c1xyXG4gICAgICBjb25zdCBkb2NSZWYgPSBkb2MoZmlyZXN0b3JlREIsICdjb21wYW55X2luc2lnaHRzJywgcXVlcnlTbmFwc2hvdC5kb2NzWzBdLmlkKTtcclxuICAgICAgY29uc3QgZXhpc3RpbmdEYXRhID0gcXVlcnlTbmFwc2hvdC5kb2NzWzBdLmRhdGEoKSBhcyBDb21wYW55SW5zaWdodHM7XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCB1cGRhdGVkRGF0YSA9IHtcclxuICAgICAgICB0b3RhbFN1Ym1pc3Npb25zOiBleGlzdGluZ0RhdGEudG90YWxTdWJtaXNzaW9ucyArIDEsXHJcbiAgICAgICAgY29tbW9uRmxhZ3M6IEFycmF5LmZyb20obmV3IFNldChbLi4uZXhpc3RpbmdEYXRhLmNvbW1vbkZsYWdzLCAuLi5zdWJtaXNzaW9uRGF0YS5tYXJrZWRGbGFnc10pKSxcclxuICAgICAgICBhdmVyYWdlRmxhZ0NvdW50OiAoZXhpc3RpbmdEYXRhLmF2ZXJhZ2VGbGFnQ291bnQgKiBleGlzdGluZ0RhdGEudG90YWxTdWJtaXNzaW9ucyArIHN1Ym1pc3Npb25EYXRhLm1hcmtlZEZsYWdzLmxlbmd0aCkgLyAoZXhpc3RpbmdEYXRhLnRvdGFsU3VibWlzc2lvbnMgKyAxKSxcclxuICAgICAgICBzZXZlcml0eVRyZW5kczoge1xyXG4gICAgICAgICAgbGlnaHQ6IGV4aXN0aW5nRGF0YS5zZXZlcml0eVRyZW5kcy5saWdodCArIHN1Ym1pc3Npb25EYXRhLnNldmVyaXR5QnJlYWtkb3duLmxpZ2h0LFxyXG4gICAgICAgICAgbWVkaXVtOiBleGlzdGluZ0RhdGEuc2V2ZXJpdHlUcmVuZHMubWVkaXVtICsgc3VibWlzc2lvbkRhdGEuc2V2ZXJpdHlCcmVha2Rvd24ubWVkaXVtXHJcbiAgICAgICAgfSxcclxuICAgICAgICBsYXN0VXBkYXRlZDogc2VydmVyVGltZXN0YW1wKClcclxuICAgICAgfTtcclxuICAgICAgXHJcbiAgICAgIGF3YWl0IHVwZGF0ZURvYyhkb2NSZWYsIHVwZGF0ZWREYXRhKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIENyZWF0ZSBuZXcgY29tcGFueSBpbnNpZ2h0c1xyXG4gICAgICBhd2FpdCBhZGREb2MoY29sbGVjdGlvbihmaXJlc3RvcmVEQiwgJ2NvbXBhbnlfaW5zaWdodHMnKSwge1xyXG4gICAgICAgIGNvbXBhbnlOYW1lOiBub3JtYWxpemVkQ29tcGFueU5hbWUsXHJcbiAgICAgICAgdG90YWxTdWJtaXNzaW9uczogMSxcclxuICAgICAgICBjb21tb25GbGFnczogc3VibWlzc2lvbkRhdGEubWFya2VkRmxhZ3MsXHJcbiAgICAgICAgYXZlcmFnZUZsYWdDb3VudDogc3VibWlzc2lvbkRhdGEubWFya2VkRmxhZ3MubGVuZ3RoLFxyXG4gICAgICAgIHNldmVyaXR5VHJlbmRzOiBzdWJtaXNzaW9uRGF0YS5zZXZlcml0eUJyZWFrZG93bixcclxuICAgICAgICBsYXN0VXBkYXRlZDogc2VydmVyVGltZXN0YW1wKClcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIGNvbXBhbnkgaW5zaWdodHM6JywgZXJyb3IpO1xyXG4gICAgLy8gRG9uJ3QgdGhyb3cgZXJyb3IgLSBjb21wYW55IGluc2lnaHRzIHVwZGF0ZSBpcyBub3QgY3JpdGljYWxcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZ2V0Q29tcGFueUluc2lnaHRzID0gYXN5bmMgKGNvbXBhbnlOYW1lOiBzdHJpbmcpOiBQcm9taXNlPENvbXBhbnlJbnNpZ2h0cyB8IG51bGw+ID0+IHtcclxuICBpZiAoIWZpcmVzdG9yZURCKSB7XHJcbiAgICBjb25zb2xlLndhcm4oJ0ZpcmViYXNlIG5vdCBpbml0aWFsaXplZC4gQ2Fubm90IGdldCBjb21wYW55IGluc2lnaHRzLicpO1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG4gIFxyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBub3JtYWxpemVkQ29tcGFueU5hbWUgPSBub3JtYWxpemVDb21wYW55TmFtZShjb21wYW55TmFtZSk7XHJcbiAgICBcclxuICAgIGNvbnN0IGNvbXBhbnlRdWVyeSA9IHF1ZXJ5KFxyXG4gICAgICBjb2xsZWN0aW9uKGZpcmVzdG9yZURCLCAnY29tcGFueV9pbnNpZ2h0cycpLFxyXG4gICAgICB3aGVyZSgnY29tcGFueU5hbWUnLCAnPT0nLCBub3JtYWxpemVkQ29tcGFueU5hbWUpXHJcbiAgICApO1xyXG4gICAgXHJcbiAgICBjb25zdCBxdWVyeVNuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyhjb21wYW55UXVlcnkpO1xyXG4gICAgXHJcbiAgICBpZiAoIXF1ZXJ5U25hcHNob3QuZW1wdHkpIHtcclxuICAgICAgcmV0dXJuIHF1ZXJ5U25hcHNob3QuZG9jc1swXS5kYXRhKCkgYXMgQ29tcGFueUluc2lnaHRzO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBjb21wYW55IGluc2lnaHRzOicsIGVycm9yKTtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxufTtcclxuXHJcbi8vIFV0aWxpdHkgZnVuY3Rpb25zXHJcbmV4cG9ydCBjb25zdCBub3JtYWxpemVDb21wYW55TmFtZSA9IChpbnB1dDogc3RyaW5nKTogc3RyaW5nID0+IHtcclxuICByZXR1cm4gaW5wdXRcclxuICAgIC50cmltKClcclxuICAgIC50b0xvd2VyQ2FzZSgpXHJcbiAgICAucmVwbGFjZSgvXFxzKy9nLCAnICcpXHJcbiAgICAucmVwbGFjZSgvW15cXHdcXHMtXS9nLCAnJylcclxuICAgIC5yZXBsYWNlKC9cXGIoaW5jfGNvcnB8bGxjfGx0ZHxjb3xjb21wYW55KVxcYi9nLCAnJylcclxuICAgIC50cmltKCk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZ2VuZXJhdGVTZXNzaW9uSWQgPSAoKTogc3RyaW5nID0+IHtcclxuICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDE1KSArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCAxNSk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgaGFzaElQID0gYXN5bmMgKGlwOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4gPT4ge1xyXG4gIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcclxuICBjb25zdCBkYXRhID0gZW5jb2Rlci5lbmNvZGUoaXApO1xyXG4gIGNvbnN0IGhhc2hCdWZmZXIgPSBhd2FpdCBjcnlwdG8uc3VidGxlLmRpZ2VzdCgnU0hBLTI1NicsIGRhdGEpO1xyXG4gIGNvbnN0IGhhc2hBcnJheSA9IEFycmF5LmZyb20obmV3IFVpbnQ4QXJyYXkoaGFzaEJ1ZmZlcikpO1xyXG4gIHJldHVybiBoYXNoQXJyYXkubWFwKGIgPT4gYi50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSkuam9pbignJyk7XHJcbn07ICJdLCJuYW1lcyI6WyJpbml0aWFsaXplQXBwIiwiZ2V0QXBwcyIsImdldEZpcmVzdG9yZSIsImNvbGxlY3Rpb24iLCJhZGREb2MiLCJ1cGRhdGVEb2MiLCJkb2MiLCJnZXREb2NzIiwicXVlcnkiLCJ3aGVyZSIsInNlcnZlclRpbWVzdGFtcCIsImZpcmViYXNlQ29uZmlnIiwiYXBpS2V5IiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0ZJUkVCQVNFX0FQSV9LRVkiLCJhdXRoRG9tYWluIiwiTkVYVF9QVUJMSUNfRklSRUJBU0VfQVVUSF9ET01BSU4iLCJwcm9qZWN0SWQiLCJORVhUX1BVQkxJQ19GSVJFQkFTRV9QUk9KRUNUX0lEIiwic3RvcmFnZUJ1Y2tldCIsIk5FWFRfUFVCTElDX0ZJUkVCQVNFX1NUT1JBR0VfQlVDS0VUIiwibWVzc2FnaW5nU2VuZGVySWQiLCJORVhUX1BVQkxJQ19GSVJFQkFTRV9NRVNTQUdJTkdfU0VOREVSX0lEIiwiYXBwSWQiLCJORVhUX1BVQkxJQ19GSVJFQkFTRV9BUFBfSUQiLCJmaXJlYmFzZUFwcCIsImZpcmVzdG9yZURCIiwiaW5pdGlhbGl6ZUZpcmViYXNlIiwiZXhpc3RpbmdBcHBzIiwibGVuZ3RoIiwiYXBwIiwiZGIiLCJnZXRGaXJlYmFzZUFwcCIsImdldEZpcmVzdG9yZURCIiwidmFsaWRhdGVGaXJlYmFzZUNvbmZpZyIsInJlcXVpcmVkS2V5cyIsIm1pc3NpbmdLZXlzIiwiZmlsdGVyIiwia2V5IiwiY29uc29sZSIsImVycm9yIiwibG9nIiwid2FybiIsInN1Ym1pdEludGVydmlld0NoZWNrdXAiLCJkYXRhIiwiRXJyb3IiLCJzdWJtaXNzaW9uRGF0YSIsInRpbWVzdGFtcCIsImRvY1JlZiIsImNvbXBhbnlOYW1lIiwidXBkYXRlQ29tcGFueUluc2lnaHRzIiwiaWQiLCJub3JtYWxpemVkQ29tcGFueU5hbWUiLCJub3JtYWxpemVDb21wYW55TmFtZSIsImNvbXBhbnlRdWVyeSIsInF1ZXJ5U25hcHNob3QiLCJlbXB0eSIsImRvY3MiLCJleGlzdGluZ0RhdGEiLCJ1cGRhdGVkRGF0YSIsInRvdGFsU3VibWlzc2lvbnMiLCJjb21tb25GbGFncyIsIkFycmF5IiwiZnJvbSIsIlNldCIsIm1hcmtlZEZsYWdzIiwiYXZlcmFnZUZsYWdDb3VudCIsInNldmVyaXR5VHJlbmRzIiwibGlnaHQiLCJzZXZlcml0eUJyZWFrZG93biIsIm1lZGl1bSIsImxhc3RVcGRhdGVkIiwiZ2V0Q29tcGFueUluc2lnaHRzIiwiaW5wdXQiLCJ0cmltIiwidG9Mb3dlckNhc2UiLCJyZXBsYWNlIiwiZ2VuZXJhdGVTZXNzaW9uSWQiLCJNYXRoIiwicmFuZG9tIiwidG9TdHJpbmciLCJzdWJzdHJpbmciLCJoYXNoSVAiLCJpcCIsImVuY29kZXIiLCJUZXh0RW5jb2RlciIsImVuY29kZSIsImhhc2hCdWZmZXIiLCJjcnlwdG8iLCJzdWJ0bGUiLCJkaWdlc3QiLCJoYXNoQXJyYXkiLCJVaW50OEFycmF5IiwibWFwIiwiYiIsInBhZFN0YXJ0Iiwiam9pbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/firebase.ts\n"));

/***/ })

}]);